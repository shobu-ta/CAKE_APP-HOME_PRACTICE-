cakephpクイックスタートガイドの手順
Vagrant の Ubuntu に入っている MySQLに接続して空のデータベースを作成する。
コマンドはsudo mysql　→　CREATE DATABASE cake_app（例）;
USE cake_app;

1 CREATE TABLE users（ユーザーの教室）
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,　生徒番号。自動で1,2,3…と増える。教室の代表キー
    email VARCHAR(255) NOT NULL,メールアドレス。255文字まで。必須。
    password VARCHAR(255) NOT NULL,パスワード。必須。
    created DATETIME,作成日時。
    modified DATETIME更新日時。
);
2 CREATE TABLE articles（記事の教室）
CREATE TABLE articles (
    id INT AUTO_INCREMENT PRIMARY KEY,記事のID。自動採番。
    user_id INT NOT NULL,記事を書いたユーザーのID（users.id と紐づく）。
    title VARCHAR(255) NOT NULL,記事タイトル。
    slug VARCHAR(191) NOT NULL,URL用の短い文字列（例：first-post）。
    body TEXT,記事本文。長文OK。
    published BOOLEAN DEFAULT FALSE,公開フラグ。初期値は非公開。
    created DATETIME,作成日時。
    modified DATETIME,更新日時。
    UNIQUE KEY (slug),　slug は重複禁止（URLがかぶらないように）。
    FOREIGN KEY user_key (user_id) REFERENCES users(id)　user_id は users.id と結びつく外部キー。
) CHARSET=utf8mb4;
3 CREATE TABLE tags（タグの教室）
CREATE TABLE tags (
    id INT AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(191),タグ名（例：news, tech）。
    created DATETIME,
    modified DATETIME,
    UNIQUE KEY (title)タグ名は重複禁止。
) CHARSET=utf8mb4;
4 CREATE TABLE articles_tags（記事とタグの中間テーブル）
これは「多対多」を実現するための橋渡しテーブル
記事1つにタグが複数つけられる
タグ1つが複数の記事につけられる
→ 多対多（many-to-many）
→ そのために「橋」を作る必要がある
CREATE TABLE articles_tags (
    article_id INT NOT NULL,記事のID
    tag_id INT NOT NULL,タグのID
    PRIMARY KEY (article_id, tag_id),組み合わせが重複しないようにする
    FOREIGN KEY tag_key(tag_id) REFERENCES tags(id),tag_id は tags.id と紐づく
    FOREIGN KEY article_key(article_id) REFERENCES articles(id)article_id は articles.id と紐づく
);
5 INSERT INTO users（ユーザーを1人追加）
INSERT INTO users (email, password, created, modified)
VALUES
('cakephp@example.com', 'secret', NOW(), NOW());
-users テーブルに1行追加
-email = cakephp@example.com
-password = secret（本来はハッシュ化すべき）
-created = 現在時刻
-modified = 現在時
6 INSERT INTO articles（記事を1つ追加）
INSERT INTO articles (user_id, title, slug, body, published, created, modified)
VALUES
(1, 'First Post', 'first-post', 'This is the first post.', 1, now(), now());
-記事を1つ追加
-user_id = 1（つまり上のユーザーが書いた記事）
-title = First Post
-slug = first-post
-body = This is the first post.
-published = 1（公開）
-created = 現在時刻
-modified = 現在時

 まとめ：この SQL がやっているこ
 4つのテーブルを作り、初期データとしてユーザー1人と記事1つを登録しています。


 データベースの設定:セットアップを適用するために config/app.php ファイルの中の Datasources.default 配列の値を置き換える。

 最初のモデルの作成：
<?php
// src/Model/Table/ArticlesTable.php
namespace App\Model\Table;意味：
このクラスは App\Model\Table という「名前空間」に属していると宣言しています。
use Cake\ORM\Table;「株式会社ケーキフレームワーク 東京本社 ORM 部 Table 課の “Table さん” を、
ここでは“Tableさん”と呼ぶことにします」みたいな名札の短縮登録。
ORMは「プログラムのオブジェクト」と「データベースのテーブル」をつなぐ通訳者のような存在
use Cake\Validation\Validator;
use Cake\Utility\Text;
use Cake\Event\EventInterface;

class ArticlesTable extends Table
「Table さん（標準的な倉庫管理人）をベースに、
“記事用倉庫の管理人（ArticlesTable）” を作っている」イメージ。


    public function initialize(array $config): void
public外部からも呼び出せる　array $config引数$configは配列型だと約束 
void 何も値を返さない関数だと宣言
      {
        parent::initialize($config);
自分独自の準備をする前に、
まず本社マニュアルどおりの標準準備（親クラスの初期化）もちゃんとやっておきます

        // テーブル名（articles）を自動認識
        $this->setPrimaryKey('id');

        $this->addBehavior('Timestamp');
この Table に Timestamp ビヘイビアを追加しています。
これにより、articles テーブルに対してレコードを保存するときに
created と modified カラムを自動で現在時刻にしてくれるようになります。

    }

また、Articles のための Entity クラスも作成します。エンティティーは、 データベースの１つのレコードを表し、データに対して行レベルの振る舞いを提供します。

use Cake\ORM\Entity;

class Article extends Entity
{
    protected array $_accessible = [
        'title' => true,
        'body' => true,
        'published' => true,
        'created' => true,
        'modified' => true,
        'users' => true,
    ];
}

$_accessible は「どのフィールドを一括代入（mass assignment）してよいか」を指定する配列。
protected は「このクラスの中と子クラスからだけアクセスできる」という意味。
「この箱（記事）に、外からまとめて入れていい荷物はどれか？」
というルール表を作っている。

- $_accessible は「外部から代入してよいフィールド」を決める仕組み
user_id を true にすると、悪意あるユーザーが勝手に書き換えられる
それは「他人の記事を自分のものにする」などの重大な事故につながる
だから user_id は false（または未指定） にしておくのが正しい
user_id は サーバー側で安全にセットする


<?php
// src/Model/Table/ArticlesTable.php

namespace App\Model\Table;

use Cake\ORM\Table;
use Cake\Validation\Validator;
意味：バリデーション（入力チェック）を行うためのクラスを読み込む。
CakePHP の Validator は：- 必須チェック- 文字数チェック- メール形式チェック
-数値チェックなどを担当する「入力チェック係」。

use Cake\Utility\Text;
意味：文字列操作の便利ツール集を読み込む。今回使っているのは Text::slug()。
-日本語やスペースを-URL で使える “slug” 形式に変換する
-例："Hello World!" → "hello-world"

use Cake\Event\EventInterface;
意味：イベント（beforeSave など）を扱うための型を読み込む。CakePHP は「イベント駆動」で動く部分が多く、beforeSave などのイベントハンドラはこの型を使う。

class ArticlesTable extends Table
{
    public function initialize(array $config): void
    {
        parent::initialize($config);

        // テーブル名（articles）を自動認識
        $this->setPrimaryKey('id');

        // タイムスタンプビヘイビア（created, modified を自動更新）
        $this->addBehavior('Timestamp');
    }

    public function validationDefault(Validator $validator): Validator
意味：このテーブルで使う「標準のバリデーションルール」を定義する関数$validator はバリデーション設定用のオブジェクト- 戻り値も Validator 型で返す必要がある
CakePHP はこの関数を自動で呼び出し、フォーム送信時に入力チェックを行う。

    {
        $validator
            ->notEmptyString('title', 'タイトルは必須です')
            意味：title が空文字だったらエラーにする。
            ->notEmptyString('body', '本文は必須です');

        return $validator;
    }

    public function beforeSave(EventInterface $event, $entity, $options)
    {
意味：レコードを保存する直前に呼ばれる「フック（イベント）」CakePHP の保存処理は：patchEntity → validate → beforeSave → saveという流れで動く。beforeSave は「保存直前に最後の加工をする場所」。


        // 新規作成かつ slug が空の場合のみ生成
        if ($entity->isNew() && !$entity->slug) {
意味：このレコードが「新規作成」かどうかを判定する。新規作成 → true
- 編集（update） → false
slug は新規作成時だけ生成したいので、この条件が必要。

            $sluggedTitle = Text::slug($entity->title);
            // utf8mb4 の index 制限に合わせて 191 文字に調整
            $entity->slug = substr($sluggedTitle, 0, 191);
        }
    }
}

<?php
// src/Model/Table/ArticlesTable.php

namespace App\Model\Table;

use Cake\ORM\Table;
use Cake\Validation\Validator;
use Cake\Utility\Text;
use Cake\Event\EventInterface;

class ArticlesTable extends Table
{
    public function initialize(array $config): void
    {
        parent::initialize($config);

        // テーブル名（articles）を自動認識
        $this->setPrimaryKey('id');

        // タイムスタンプビヘイビア（created, modified を自動更新）
        $this->addBehavior('Timestamp');
    }

    public function validationDefault(Validator $validator): Validator
    {
意味：このテーブルで使う「標準のバリデーションルール」を定義する関数。 $validator はバリデーション設定用のオブジェクト 戻り値も Validator 型で返す必要がある　CakePHP はこの関数を自動で呼び出し、フォーム送信時に入力チェックを行う。

        $validator
            ->notEmptyString('title', 'タイトルは必須です')
            意味：title が空文字だったらエラーにする。
            ->notEmptyString('body', '本文は必須です');

        return $validator;
    }

    public function beforeSave(EventInterface $event, $entity, $options)
    {
意味：レコードを保存する直前に呼ばれる「フック（イベント）」CakePHP の保存処理は：patchEntity → validate → beforeSave → save　という流れで動く。beforeSave は「保存直前に最後の加工をする場所」。

        // 新規作成かつ slug が空の場合のみ生成
        if ($entity->isNew() && !$entity->slug) {
意味：このレコードが「新規作成」かどうかを判定する。- 新規作成 → true
編集（update） → false　slug は新規作成時だけ生成したいので、この条件が必要。
            $sluggedTitle = Text::slug($entity->title);
意味：タイトルを URL 用の “slug” に変換する。
"Hello World!" → "hello-world"
"日本語 タイトル" → "ri-ben-yu-taitoru"
URL に使える安全な文字だけにするための処理。
            // utf8mb4 の index 制限に合わせて 191 文字に調整
            $entity->slug = substr($sluggedTitle, 0, 191);
slug を 191 文字以内に切り詰める。生成した slug を entity にセットする。
        }
    }
}